package day1206;
/**
3. shift 연산자 비트밀기 연산
<< left  비트를 왼쪽으로 밀고 0으로 채운다
>> right 비트를 오른족으로 밀고 밀어서 빈칸을 최상위 부호비트에 따라 양수만 0을 음수면 1을 채운다
>>> (unsigned right ) 음수를 사용하지 않는 연산을 해야할 때
양수일때는 >> 동일
음수더라도 양수로 표현됨


>>>


*/
class Operartion3{
	public static void main(String[] args) {
		int i =3; // 0000 0000 0000 0011

		System.out.println(i+" << 3 =" + (i <<3));
		//0000 0011 << 3 =24
		//0001 1000
		i=6;
		System.out.println(i+" << 4 =" + (i <<4));
		//0000 0110 << 4 = 96
		//0011 0000 
		i=1; //0000 0000 0000 0000 0000 0000 0000 0001
		System.out.println(i+" << 31 =" + (i <<31));
		

		System.out.println(i+" << 32 =" + (i <<32));
		i=2;
		System.out.println(i+" << 31 =" + (i <<31));
		//0000 0000 0000 0000 0000 0000 0000 0010 << 31
		//

		i=40;
		System.out.println(i+" >> 2 =" + (i >>2));
		//0010 1000 >> 2 = 0000 1010 

		i=36;
		System.out.println(i+" >> 4 =" + (i >>4));
		//0000 0010 

		i=-1;
		System.out.println(i+" >> 100 =" + (i >>100)); //-1

		i =32;//양수일 때는 >>와 동일한 연산
		System.out.println(i+" >>> 3 =" + (i >>>3));
		//0010 0000 >>> 3 = 0000 0100

		i=-1;
		System.out.println(i+" >>>1 =" + (i >>>1));
		//1111 1111 1111 1111 1111 1111 1111 1111
		//0111 1111 1111 1111 1111 1111 1111 1111

		i=-10 >>> 4;
		//1111 1111 1111 1111 1111 1111 1111 0110 >>> 4
		//= 0000 1111 1111 1111 1111 1111 1111 1111 
		System.out.println(i);


	}
}
